package jimm.datavision.source.charsep;
import java.io.Reader;
import java.io.IOException;
import java.util.List;
import java.util.ArrayList;

/**
 * Parses delimited data. Handles quotes and embedded delimiters.
 *
 * @author Jim Menard, <a href="mailto:jimm@io.com">jimm@io.com</a>
 */
public class DelimParser {

public static final int EOF = -1;

protected char delimiter;
protected Reader in;
protected int pushbackChar;

/**
 * Constructor, using ',' as the delimiter. The caller must close
 * <var>in</var>.
 *
 * @param in input reader
 */
public DelimParser(Reader in) {
    this(in, ',');
}

/**
 * Constructor. The caller must close <var>in</var>.
 *
 * @param in input reader
 * @param delimiter delimiter character
 */
public DelimParser(Reader in, char delimiter) {
    this.delimiter = delimiter;
    this.in = in;
    pushbackChar = EOF;
}

/**
 * Returns an array of column data or <code>null</code> if there is no more
 * data. Handles delimiters and quotes within the data just as they are
 * generated by Excel comma- and tab-separated files.
 *
 * @return a <code>List</code> of strings; return <code>null</code> if
 * there is no more data.
 */
public List parse() throws IOException {
    ArrayList columns = null;
    boolean insideQuotes = false;
    int numQuotesSeen = 0;
    StringBuffer buf = new StringBuffer();

    int charAsInt;
    char c;
    char prevChar = '\0';
    while ((charAsInt = nextChar()) != EOF) {
	c = (char)charAsInt;

	switch (c) {
	case '"':		// Quote character
	    if (!insideQuotes) { // Start of quoted column
		insideQuotes = true;
		numQuotesSeen = 0;
	    }
	    else if (insideQuotes) { // Inside quoted column
		if (numQuotesSeen == 1) { // This is second of doubled quotes
		    buf.append(c);
		    numQuotesSeen = 0;
		}
		else
		    numQuotesSeen = 1;
	    }
	    break;
	case '\n':		// Linefeed/newline
	case '\r':
	    if (insideQuotes) {
		if (numQuotesSeen == 1) { // Closing quote at end of line
		    if (columns == null) columns = new ArrayList();
		    columns.add(buf.toString());
		    return columns;
		}
		else
		    buf.append(c);
	    }
	    else {		// End of line; return columns
		// Handle DOS line endings
		if (c == '\r')	{ // Check for following '\n
		    charAsInt = nextChar();
		    c = (char)charAsInt;
		    if (c != '\n')	// Eat following '\n' if it exists
			pushback(charAsInt); // Else put it back
		}

		charAsInt = nextChar();
		c = (char)charAsInt;
		if (columns == null && buf.length() == 0 && charAsInt == EOF)
		    return null; // Empty line at end of file

		pushback(charAsInt);
		if (columns == null) columns = new ArrayList();
		columns.add(buf.toString());
		return columns;
	    }
	    break;
	default:
	    if (c == delimiter) { // Normal delimiter
		if (!insideQuotes) {
		    if (columns == null) columns = new ArrayList();
		    columns.add(buf.toString());
		    buf = new StringBuffer();
		}
		else {		// Inside quoted column
		    // Delimiter at end of quoted column data
		    if (numQuotesSeen == 1) {
			insideQuotes = false;
			if (columns == null) columns = new ArrayList();
			columns.add(buf.toString());
			buf = new StringBuffer();
		    }
		    // Delimiter inside quoted column
		    else
			buf.append(delimiter);
		}
	    }
	    else {		// Everything else
		numQuotesSeen = 0;
		buf.append(c);
	    }
	    break;
	}

	prevChar = c;
    }

    // We've reached EOF
    if (columns == null && buf.length() == 0) // Empty line at end of file
	return null;

    if (buf.length() > 0 || prevChar == delimiter) {
	if (columns == null) columns = new ArrayList();
	columns.add(buf.toString());
    }
    return columns;
}

protected int nextChar() throws IOException {
    if (pushbackChar == EOF)
	return in.read();
    else {
	int c = pushbackChar;
	pushbackChar = EOF;
	return c;
    }
}

protected void pushback(int charAsInt) {
    pushbackChar = charAsInt;
}

}
